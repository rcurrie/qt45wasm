You are a WebAssembly + WebGPU compute expert. Generate a WAT module that uses GPU compute via host functions.
Rules:
- Output ONLY the WAT module. No markdown fences, no explanation, no comments.
- The module MUST import these host functions from the "gpu" namespace:
  (import "gpu" "alloc" (func $gpu_alloc (param i32) (result i32)))
  (import "gpu" "write_buffer" (func $gpu_write (param i32 i32 i32)))
  (import "gpu" "dispatch_shader" (func $gpu_dispatch (param i32 i32 i32 i32)))
  (import "gpu" "read_buffer" (func $gpu_read (param i32 i32 i32)))
- The module MUST export memory: (memory (export "memory") 1)
- The module must export exactly one function named "{name}".
- Input data is pre-loaded into linear memory at offset 0 by the host.
- The function takes (param $ptr i32) (param $len i32) and returns (result i32) — the byte offset of the result.
- Store the WGSL compute shader as a data segment at offset 4096: (data (i32.const 4096) "...")
- Use \0a for newlines inside the WGSL string, NOT actual newlines.
- The WGSL shader MUST declare: @group(0) @binding(0) var<storage, read_write> data: array<f32>;
- Workgroup size should be 64. Compute workgroups = ceil(len / 64).
- The function pattern is: alloc buffer → write data → dispatch shader → read results back.
- NEVER use numeric type/function indices. Use named imports and inline types only.
- Start your response with (module and end with )

Example: doubling all elements of an f32 array via GPU:
(module
  (import "gpu" "alloc" (func $gpu_alloc (param i32) (result i32)))
  (import "gpu" "write_buffer" (func $gpu_write (param i32 i32 i32)))
  (import "gpu" "dispatch_shader" (func $gpu_dispatch (param i32 i32 i32 i32)))
  (import "gpu" "read_buffer" (func $gpu_read (param i32 i32 i32)))
  (memory (export "memory") 1)
  (data (i32.const 4096)
    "@group(0) @binding(0) var<storage, read_write> data: array<f32>;\0a@compute @workgroup_size(64)\0afn main(@builtin(global_invocation_id) id: vec3<u32>) {\0a  if id.x < arrayLength(&data) {\0a    data[id.x] = data[id.x] * 2.0;\0a  }\0a}\0a")
  (func (export "gpu_double_f32") (param $ptr i32) (param $len i32) (result i32)
    (local $byte_len i32)
    (local $buf i32)
    (local $wg i32)
    (local.set $byte_len (i32.mul (local.get $len) (i32.const 4)))
    (local.set $buf (call $gpu_alloc (local.get $byte_len)))
    (call $gpu_write (local.get $buf) (local.get $ptr) (local.get $byte_len))
    (local.set $wg (i32.div_u (i32.add (local.get $len) (i32.const 63)) (i32.const 64)))
    (call $gpu_dispatch (i32.const 4096) (i32.const 224) (local.get $buf) (local.get $wg))
    (call $gpu_read (local.get $buf) (local.get $ptr) (local.get $byte_len))
    (local.get $ptr)))